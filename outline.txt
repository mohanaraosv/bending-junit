JUnit philosophies
   -- OCP
   -- Keep the core small
   -- Tests should:
      -- self-check
      -- be isolated
      -- be order-independent
      -- be repeatable
      -- have one reason to fail
      -- clearly communicate intent

JUnit 3 to 4
   -- no need for TestCase superclass
   -- test____() --> @Test
   -- Template methods setUp()/tearDown() --> @Before/@After
   -- No guaranteed order of @(Before|After)(Class)

assertThat()
   -- "How come JUnit doesn't have assert____()?"
   -- assertEquals, assert(Not)Same, assert(Not)Null, assert(True|False),
   fail
   -- <T> assertThat(T target, Matcher<T> matcher)
   -- For example:
      assertThat("radar", isPalindrome);
      
      where PalindromeMatcher.

   -- Matcher violates SRP.
   
   -- What about a matcher that has a predicate and a description builder
      injected?

Rules
x   ExpectedException
x   TempFolder
x   TestName
x   Logging
x   Others from core JUnit
   Writing own:
x      -- FixedClock
x      -- reset sys props
      (or, use PropertyBinder.getSystemProperties())
x   -- No guaranteed order (gh-issue)
   -- Alistair Israel rules

x M - Parameterized tests

x T - Suites

x W - Categories

x TH - ClasspathSuite

x  TH - ClasspathSuite + named category?

Su/M 
x - Theories
x    -- DataPoint(s)
    -- Mod10
x     -- ParameterSupplier
    -- quickcheck

M/T/W - Writing own Runner

-- map out responsibilities of collaborating classes in a Runner

    -- Enclosed Inners
